\chapter{Discussion}
\label{cha:discussion}
\epigraph{Isn't that reverse hot reloading?}{Stefan Baumgartner}
\noindent This quote was the first thing that came to Stefan Baumgartner's mind when he saw the Sidecar application interacting with the parent console application.
Hot reloading is a technique embraced by many modern web and native frameworks to tighten the feedback loop between a code change and being able to test it in the application.
This is accomplished by not having to restart the application \cite{czaplicki_interactive_2013}.
But what is its reverse?
Reverse hot reloading can be interpreted as tightening the feedback loop of changing parts of an application by not having to change code.
Side effects are abstracted and, as such, can be modified at runtime.
Although this discovery was not the primary intention of this thesis, tightening the feedback loop was.
Reflecting on the research question, this section summarizes the findings, contributions, and limitations and proposes ideas for future research.

\section{Summary}
\label{sec:discussion-summary}
Starting with the idea of interactive programming, we presented the advantages of tight feedback loops and how this concept supports the agile idea of developing software.
After considering some historical perspectives of agile software development, we applied this narrative to the current state of prototyping before we viewed programming as complex problem-solving.
Applying insights from psychology, such as cognitive load and programming as theory building, we discussed existing solutions for tackling such problems, namely todo comments and Hole-Driven Development.
This led us to the following research question: \emph{Analyzing hole-driven development and existing solutions regarding the handling of todo comments, which of these concepts can be transferred to widely used general-purpose programming languages?}

After analyzing existing solutions regarding todo comments, programming languages with support for holes, and how hole-like concepts are simulated in other programming languages, we derived a list of properties intrinsic to holes (Section~\ref{sec:relevant-properties}).
By implementing \emph{Holey} and carefully applying the ideas of these hole properties, our proof of concept showed that existing concepts of Hole-Driven Development can be either implemented, simulated, or rebuilt based upon existing features in the general-purpose programming language \CS.
Although native support for holes is unattainable for ad-hoc solutions, approaching prototyping and software quality with Hole-Driven Development in mind enabled novel aspects in terms of gradually refining requirements and decomposing them by writing code.


\section{Contributions}
\label{sec:discussion-contributions}
In terms of contributions, we proposed to look at agile development practices through the lens of tightening feedback loops.
This might explain or clarify some historical developments regarding the adaption, success, and difficulties of adapting agile software development.

Regarding Hole-Driven Development, we broadened the view of what can be considered a hole by introducing the fill-in-the-blanks exercise analogy.
This allowed us to view the bigger picture of possible holes and integrate widely used todo comments and different ways of simulating holes into the narrow definition of holes in statically typed functional programming languages.
We do not want to weaken the definition of Hole-Driven Development.
Still, we believe that the concept of holes can impact how we approach software development if it were more easily accessible.

By implementing Holey in \CS, we showed that Hole-Driven Development approaches can be realized in widely used general-purpose programming languages.
While creating our version in \CS, we collected necessary language and ecosystem features that enable Hole-Driven Development in other programming languages (compare Section~\ref{sec:holey-enabling-language-independence}).

As we focused on the simplicity and extensibility of Holey, we showed that only a few simple primitives suffice for implementing powerful language-independent extensions such as the Sidecar application.
By also making the individual parts of the Sidecar application composable, we are curious to see what other researchers and practitioners come up with in extending Holey.
We present some of our future ideas in Section~\ref{sec:discussion-future-ideas}.


\section{Applications}
\label{sec:discussion-applications}
As already described thoroughly in Chapter~\ref{cha:introduction}, we see the main application of Hole-Driven Development in shortening the feedback loops in experimental and prototypical development environments.
It could also help in scenarios where evolutionary prototypes (compare Section~\ref{sec:prototyping}) have to be evolved into releasable products.
Hole-Driven Development could be used to quickly create prototypes for stakeholder communication while its compile time information prevents prototypical code from being released into production.

Another possible application is the usage of Holey combined with its Sidecar application during ideation sessions with technology-interested stakeholders.
Reaching a shared understanding (a theory) could be fostered by testing how a prototype behaves collaboratively.
Ideas could be explored interactively, and edge cases could be explored together.

Hole-Driven Development could be used as a communication tool in pair-programming scenarios.
It could provide the basis for multiple developers to iterate together on a code base.
In Edwin Brady's sense of "the compiler as a lab assistant" \cite{brady_type-driven_2017}, Holey could also act as temporary todo notes or checklists that aid the development in a way that suits individual developers.
One such workflow might be the continuous introduction and removal of holes until a feature is developed with the addition that additional refactoring tasks or ideas alongside are introduced at holes to stay in the flow.
Once the feature is finished, these holes could be converted to tickets so that technical debt becomes visible and can be planned for.

Hole-Driven Development could also be utilized in educational settings.
As already suggested by Martin Odersky with Scala's \verb|???|-operator \cite{odersky_adding_2011}, tasks could be prepared in the form of holes, and students would have to implement those.
Starting with executable holes would allow them to experiment with the program already in its initial state, thus reducing the hurdles of starting with nothing.
If the holes are explained well, the assignment could be to make the program runnable in release mode (without any warnings or errors).

%\todo[inline]{Another application might be the applicability of Holey to full-fledged programming languages like Python, which would enable building a Debug-UI for certain departments inside a (dev-heavy) company. As an example, data scientists could provide in-house clients parametrizable queries.}
%\todo[inline]{Holey might be used in traditional pair-programming scenarios, or for fostering dev2dev-communication by allowing them to iterate over more abstract ideas.}


\section{Limitations}
\label{sec:discussion-limitations}
This thesis' most significant limitation is its nature of being a feasibility study; people might simply not need it.
No empirical user studies have been conducted; the sole purpose was to create a proof of concept as the basis for conducting such user studies.
Holey follows best practices, and we respected the feedback of experts to whom we have shown intermediate prototypes.
However, neither its API design nor the tooling around has been validated in terms of usability or user experience.

Another limitation might be the abstraction level and its accompanying lack of clarity.
Holey might be perceived as a simple linter, which is partly correct, but the main idea of applying Hole-Driven Development to mainstream general-purpose programming languages has much more impact.
People already asked why to use Hole-Driven Development instead of Test-Driven Development.
This indicates a lack of clarity as well.
Hole-Driven Development should aid in exploring problem spaces, Test-Driven Development aids in constraining them.

Holey was developed and tested mainly in Visual Studio.
Although most features should be supported in other IDEs out of the box because of Roslyn's abstractions, this has not been validated.
Furthermore, no studies regarding Holey's effect on performance have yet been conducted.


\section{Future Research}
\label{sec:discussion-future-research}
Addressing the limitations of Section~\ref{sec:discussion-limitations}, follow-up studies regarding the applicability of Hole-Driven Development in general-purpose programming languages and the usability of Holey should be conducted.
Ideally, they should be designed using a mixed-methods approach to measure the impact of Holey's usage on software quality as well as quality-of-life improvements for the developers.
We do not believe that Holey should be measured strictly in terms of performance improvements regarding the outcome of programming because, as explained in Chapter~\ref{cha:introduction} there is so much more to software development than programming.
The qualitative aspect of such a study could also target the understanding of Hole-Driven Development in general and address the lack of clarity and knowledge around this topic.

Continuing the idea of Holey, future research should be conducted regarding the transferability of Holey's ideas to other programming languages.
It would be interesting to compare its applicability to programming languages with different paradigms and investigate how other paradigms enable or prevent the implementation of specific properties of holes.
Another area of research might be the application of Hole-Driven Development to data science.
Composing data pipelines and extracting features is typically highly explorative; as such, applying ideas of Hole-Driven Development might be beneficial.

Regarding Holey itself, it would be interesting to see how it behaves in other integrated development environments as well as other platforms (e.g., mobile apps, websites, Office plug-ins).
Holey's Sidecar application could provide the basis for future feasibility studies, especially in regard to integrations with low-code or no-code platforms.
Section~\ref{sec:discussion-future-ideas} lists some ideas regarding future research in this area.


\section{Future Ideas}
\label{sec:discussion-future-ideas}
As many sections of this thesis described the openness of problem spaces and explorative ways of approaching them, we want to conclude it with a list of ideas that emerged while writing this thesis but would have gone beyond the scope of this thesis.
As such, these ideas can be seen as this thesis' holes:
\begin{itemize}
    \item Holey's Sidecar application could be extended with support for record and replay, which would allow developers to automatically simulate their applications while still being able to explore them (credits: Anton Risberg Alaküla).
    \item The existing infrastructure of the Sidecar extension could be used to provide bidirectional Observable values for controlling and inspecting applications remotely. Additionally, these inputs and outputs could be displayed as a graph on an open canvas (credits: Dominik Angerer).
    \item \emph{tree-sitter}\footnote{\url{https://tree-sitter.github.io/tree-sitter}} should be inspected to determine how language-agnostic a tool such as Holey could be built.
    \item The \emph{Static Analysis Results Interchange Format} (SARIF) should be analyzed on whether it might provide benefits for the interchangeability of holes.
    \item Engraft \cite{horowitz_engraft_2023}, an API for Live, Rich, and Composable Programming could be integrated into Holey's Sidecar application, which would bridge between text-based programming and interactive low-code programming in a language-agnostic way.
    \item Large language models could be used for program synthesis using a hole's description as the prompt (credits: Clayton Lewis).
\end{itemize}


%\section{Reflecting on this thesis}
%\todo[inline]{nota-lang, subjectivity, types of research}