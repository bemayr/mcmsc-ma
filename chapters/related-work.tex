\chapter[Related Work]{Related Work \protect{\estimatedpagecount{15}}}
\label{cha:related-work}
\epigraph{We should think of the compiler as being our lab assistant.}{Edwin Brady}

Following Edwin Brady's philosophy of compiler's being our lab assistant, this section will provide an overview of existing solutions targeting the problem of rotting todo-comments as well as existing implementations of hole-driven development.
After presenting this existing implementations, we will highlight established, novel as well as creative work-arounds and alternatives for simulating holes in broadly used languages.
This chapter will be concluded with a list of properties, intrinsic to managing todo-comments as well as working with holes while developing software.

\section[Tackling Todo-Comments]{Tackling Todo-Comments \protect{\estimatedpagecount{4}}}
\todo[inline,color=blue!40]{Mention again that Todo-Comments tend to rot}
\todo[inline]{Shortly explain the usage of Todo-Comments again, before mentioning that there are a couple of other tools as well that tackle the problem of Todo comments}
\todo[inline]{Hightlight PEP--350 Codetags and TrigIt, because of their novel approaches regarding Todo-Comments}

\subsubsection{PEP--350 Codetags}
One of the most elaborate ideas regarding the handling of todo-comments was introduced by Micah Elliot \cite{elliott_pep_2005}.
The Python Enhancement Proposal (PEP) \emph{PEP 350 -- Codetags} was aimed at standardizing code comments acting as tags.
PEPs are design documents, which inform the Python community about newly proposed features for the Python ecosystem.
They act as the primary mechanism for discussing and iterating on those ideas by collecting community input.
Note that, them being mainly proposals, they do not have to be accepted.

As Described by \citeauthor{elliott_pep_2005} \cite{elliott_pep_2005}: "Programmers widely use ad-hoc code comment markup conventions to serve as reminders of sections of code that need closer inspection or review. Examples of markup include FIXME, TODO, XXX, BUG, but there many more in wide use in existing software."
This definition resembles the idea of todo-comments, introduced in \ref{sec:introduction-about-todo-comments}.
Todo-comments can be seen as a "very lightweight programming micro-paradigm" \cite{elliott_pep_2005} and can be useful for project management, documentation , change tracking and project health monitoring.
\cite{elliott_pep_2005} described the philosophy of codetags as such,
\begin{enumerate*}[label=(\roman*)]
\item information should be contained inside the source code,
\item it should not be duplicated,
\item documentation based on this information should be auto-generated,
\item the developers are the documentation team, and
\item plain text is the best format for writing anything
\end{enumerate*}.
Based on this philosophy, their motivation consists of \cite{elliott_pep_2005}:
\begin{itemize}
  \item Various productivity tools can be built around codetags. These tools can generate documentation like roadmaps, track their history, provide statistics and insights regarding codetags, lint them and enable them to be edited in any text editor.
  \item They encourage consistency, because some kind of formality is introduced into otherwise informal textual comments.
  \item They encourage the adherence to the DRY principle, because no separate roadmap document has to be maintained if it is generated based on these codetags.
  \item How to write codetags must be easy to remember, concise and intuitive. Their format must be simple.
  \item Their usage is not required or imposed.
  \item Generating reports based on their usage gives a global view of the code.
  \item They can be used to incrementally capture requirements and stories when they come up during development.
  \item Their extremely lightweight process does not disturb developers. Codetags can either be linked to existing issues in ticket management systems or they allow their creation to be deferred until developers can devote to their creation without interfering with programming.
\end{itemize}

The actual definition of Python's codetags consists of a special syntax definition (please refer to the specification section of \cite{elliott_pep_2005} for more information) for the different parts of informal comments, thus introducing a decent kind of formality.
Program~\ref{fig:pep-350-codetags-example} shows the usage of codetags.
The code comment starts with the mnemonic \texttt{FIXME}, and provides actual information about the comment after the colon.
At the end of a codetag, additional fields can be specified inside angle brackets.
This specific codetag is assigned to a pair of programmers, identified by their initials \texttt{MDE} and \texttt{CLE}, the date of expected completion is denoted by \texttt{d:14w} and the item's priority is 2, identified by \texttt{p:2}. 
%
\begin{program}[h]
\begin{PythonCode}
# FIXME: Seems like this loop should be finite. <MDE,CLE d:14w p:2>
while True: ...
\end{PythonCode}
\caption{Example of the usage of a PEP 350 -- Codetag}
\label{fig:pep-350-codetags-example}
\end{program}
%
Unfortunately, the PEP 350 proposal was rejected, because there was no desire to make the stand library conform to the standard, although the community was interested and some projects adopted it \cite{elliott_pep_2005}.


% - \url{https://medium.com/hackernoon/never-forget-anything-before-after-and-while-coding-98d187ae4cf1#.czqio0b4x}
\subsubsection{TrigIt}
\subsubsection{TagSEA \cite{storey_how_2009}}
\subsubsection{Tickgit}
\subsubsection{Catana}
\subsubsection{imdone}
\subsubsection{Editor Integrations}
\subsubsection{Editor Plugins}



\section[Languages with native Holes support]{Languages with native Holes support \protect{\estimatedpagecount{6}}}
\todo[inline]{Mention that a couple of languages natively support the concept of Holes}
\todo[inline]{\textbf{make sure that those are sorted by invention date}}

\subsubsection{Coq}

\subsubsection{Agda}

\subsubsection{Haskell}
\todo[inline,color=blue!40]{maybe do some research regarding Liquid Haskell}

\subsubsection{Hazel}
%https://www.youtube.com/watch?v=UkDSL0U9ndQ
%the gap problem
%what you start with is a hole
%what should we fill this hole with (in-class)
%regarding machine learning: having a theory of incomplete programs allows us to do it this way
%splicing: putting holes inside text

\subsubsection{Idris}

\section[Simulating Holes in other Languages]{Simulating Holes in other Languages \protect{\estimatedpagecount{5}}}
\subsubsection{\CS}
\todo[inline]{NotImplementedException}
\todo[inline]{dynamic}
\todo[inline,color=green!40]{relevant literature: \cite{microsoft_notimplementedexception_2020}}

\subsubsection{Java}
\todo[inline,color=green!40]{relevant literature: \cite{omar_active_2012}}

\subsubsection{Scala}
\todo[inline]{???}
\todo[inline,color=green!40]{relevant literature: \cite{odersky_adding_2011}}

\subsubsection{Swift}
\todo[inline]{do some research on this}

\subsubsection{Rust}
\todo[inline]{!todo}
\todo[inline]{!unimplemented}

\subsubsection{TypeScript}
\todo[inline]{Mention that the difference here is that we apply Holes at the type level}
\todo[inline]{Explain the idea of gradial refinement}
\todo[inline]{any + NoImplicitAny}
\todo[inline]{unknown}
\todo[inline]{eslint}

\subsubsection{\LaTeX}
\todo[inline]{explain how todo comments can be used while writing a \LaTeX document}
\todo[inline]{Mention the properties of a couple of \LaTeX-packages: todonotes, easy-todo, fixmetodonotes, todo, fixme}
\todo[inline]{Highlight the comments on ctan (for the todonotes-package) of how useful todos are when collaborating on a document}
%- https://ctan.org/pkg/todonotes
%- https://ctan.org/pkg/easy-todo
%- https://ctan.org/pkg/fixmetodonotes
%- https://ctan.org/pkg/todo
%- https://ctan.org/pkg/fixme
%  - \#Controlling the behavior of FiXme shows the idea of Release/Debug mode

\section{Properties of Holes}
\label{sec:relevant-properties}
\todo[inline]{Refer to Cyrus Omar's talk about Hazel regarding the properties of Holes as a basis}
\todo[inline]{Then cautiously add the other properties of Holes discovered in the literature research}

% add latex section based on https://tex.stackexchange.com/a/547871

\begin{description}
   \item[Holes DSL] A \CS-internal domain specific language to construct holes, which is loosely based on PEP 350 -- Codetags \cite{elliott_pep_2005}, \textsc{TrigIt} \cite{nie_framework_2019} and the comment types identified in \cite{ying_source_2005}.
   \item[Executability] The main promise of hole-driven comments is their executability. One should be able to already run an under-specified program and choose some of the unspecified behavior at runtime.
   \item[Hole Reporting] To provide value to the programmer, the holes need to be reported. Roslyn Analyzers provide capabilities to analyze the source code and report errors independent of the used editor. These can be used to detect and report the holes.
   \item[Build Differentiation] Enabling simulation capabilities can be implemented by supporting different configurations in different build variants. As an example, users might want to simulate holes in a debug build while breaking the release build due to under-specified behavior.
   \item[Support Mocking Libraries] Providing data at run-time might not always be the best solution (e.g. timing issues, no user interface, $\dotsc$), so users should be able to integrate external mocking libraries that provide the data.
   \item[Refactoring Integrations] Based on Roslyn's analyzers and code fixes, certain refactoring operations could be offered to developers. This should work like \textsc{TrigIt}'s code manipulations \cite{nie_framework_2019} or Idris' heuristics \cite{brady_type-driven_2017}.
   \item[Comment Transformation] Again, Roslyn should make it possible to analyze an existing project and transform existing TODO-comments into holes.
\end{description}